'''
The PMJQ Unix security model
================================

PMJQ relies on standard Unix tooling and permissions to make sure a rogue,
compromised of buggy program can do only limited damage.

A folder should only be read by one invocation at a time (but can be read by
multiple instances of the same invocation).

It is technically possible to have a folder be read by multiple invocation, but
it is not advisable as the behavior is undefined : which invocation will
process a file in the folder is anyone's guess. It also breaks the PMJQ unix
security model.

The PMJQ UNIX security model is as follow:

- Each directory is owned by a specific group
- Each invocation (and thus the processes it launches) is run by a specific\
user.
- This user owns all the input directories.
- This user belongs to the groups of the input and output directories of its\
invocation.

That way, if a process launched by an invocation of ``pmjq`` goes awry, it
will at most do damage only in its input and output folders, and nowhere else.

This security model is enforced by using the scripts generated by
``pmjq_interactive``.
Tools
======

``pmjq_interactive`` usage
-----------------------------

The ``pmjq_interactive`` tool generates three shell scripts.
 - The first one (``setup.sh``) creates the directories, users and groups and\
sets the permissions.
 - The second one (``launch.sh``) launches the daemons.
 - The last one (``cleanup.sh``) removes the directories, users and groups.

The user is asked, in order:
 - which command ``pmjq`` is supposed to launch,
 - which are the input directories,
 - which are the output directories.

This tuple ``(input, cmd, output)`` is called an `invocation`, because it will,
in ``launch.sh``, map to one invocation of ``pmjq``.

A transcript of a user setting up the first two invocations of our example
pipeline using this tool would begin like this::


    Command:decode
    Input dir(s):input/
    Output dir(s):decoded/
    Command:stabilize
    Input dir(s):decoded/
    Output dir(s):stabilized/


The generated scripts may have to be tweaked afterwards to add
mounting/unmounting of remote, RAM or virtual file systems, or to add options
(e.g. ``--max-load``) to the invocations of ``pmjq``. They lend themselves
quite well to merging, diffing and version control.

The ``pmjq_interactive`` tool can also be used non interactively, by storing
in a file the answers one would give to the tool's questions. Comments can be
added by starting a line with a #, such as:

.. literalinclude:: ../paper/whole_pipeline.txt

Such a file may be used on the command line with::

    grep -v -E '^#' < whole_pipeline.txt | pmjq_interactive



'''
from collections import namedtuple
from .templates import SETUP_TEMPLATE, MKDIR_TEMPLATE

Invocation = namedtuple('Invocation', 'inputs,command,outputs,pattern')
Invocation.__doc__ = 'This data structure represents one invocation of pmjq'


def invocation_name(invocations, inv):
    '''Return a short unique name for the given invocation'''
    short_name = inv.command.split(' ')[0]
    if sum([i.command.startswith(short_name) for i in invocations]) < 2:
        return short_name
    return short_name+'_'+str(abs(hash(' '.join(inv.inputs) +
                                       inv.command +
                                       ' '.join(inv.outputs))))[:3]


def read_user_input():
    '''Prompt the user, create invocations and return them'''
    answer = set()
    while True:
        command = input('Command:')
        if command == '':
            break
        inputs = tuple(sorted(input('Input dir(s):').split(' ')))
        pattern = '(.*)'
        if len(inputs) > 1:
            pattern = input('Pattern (default "(.*)"):') or pattern
        outputs = tuple(sorted(input('Output dir(s):').split(' ')))
        answer.add(Invocation(inputs, command, outputs, pattern))
    return answer


def dir2group(invocations):
    '''Return the groups and directories that ought to be created

    First, there is one group per input directory.

    Then, there is one group per global output directory.

    A global output directory is a directory no pmjq invocation reads from,
    and in which, consequently, data will accumulate (presumably to be used
    by a human).

    The returned values is a dictionary that maps directory names to the group
    that own them.
    '''
    directories = set(d for i in invocations for d in i.inputs) |\
        set(d for i in invocations for d in i.outputs)
    output_dirs = directories - \
        set(d for i in invocations for d in i.inputs)
    dir2groups = {d: 'pg_'+d for d in output_dirs}
    for i in invocations:
        if len(i.inputs) > 1:
            for j, d in enumerate(i.inputs):
                dir2groups[d] = 'pg_'+invocation_name(invocations, i)\
                                + '_'+str(j)
        else:
            dir2groups[i.inputs[0]] = 'pg_'+invocation_name(invocations, i)
    print(dir2groups.keys())
    return dir2groups


def user2groups(invocations):
    '''Return the users that ought to be created

    There is one user per pmjq invocation.

    This user belongs to the groups that own their input and output dirs.

    The returned value is a dictionary that maps users to the groups they
    belong to.
    '''
    d2g = dir2group(invocations)

    def groups(i):
        return [d2g[d] for d in i.inputs + i.outputs]
    return {'pu_'+invocation_name(invocations, i): groups(i)
            for i in invocations}


def groupadd(invocations):
    '''Return the groupadd part of the setup script'''
    return '\n'.join(sorted(['groupadd '+grp
                             for grp in dir2group(invocations).values()]))


def usermod(invocations):
    '''Return the usermod part of the setup script'''
    return 'usermod -a -G '+','.join(sorted(dir2group(invocations).values()))\
        + ' `whoami`'


def useradd(invocations):
    '''Return the useradd part of the setup script'''
    u2g = user2groups(invocations)

    def useradd_line(user):
        groups = u2g[user]
        if len(groups) == 1:
            return 'useradd -M -N -g {group} {user}'.format(user=user,
                                                            group=u2g[user])
        else:
            return 'useradd -M -N -g {group} -G {other_groups} {user}'\
                .format(user=user, group=u2g[user][0],
                        other_groups=','.join(u2g[user][1:]))
    return '\n'.join(useradd_line(u)
                     for u in sorted(user2groups(invocations).keys()))


def mkdir(invocations):
    '''Return the mkdir part of the setup script'''
    d2g = dir2group(invocations)
    return '\n'.join(MKDIR_TEMPLATE.format(directory=d,
                                           group=d2g[d],
                                           user='pu_'+d)
                     for d in sorted(d2g.keys()))


def setup(invocations):
    '''Return the text of the setup script'''
    return SETUP_TEMPLATE.format(groupadd=groupadd(invocations),
                                 usermod=usermod(invocations),
                                 useradd=useradd(invocations),
                                 mkdir=mkdir(invocations))
