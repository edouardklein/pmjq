'''
The ``pmjq`` UNIX security model
================================

``pmjq`` relies on standard UNIX tooling and permissions to make sure a rogue,
compromised, or buggy program can do only limited damage.

A folder should only be read by one invocation at a time (but can be read by
multiple instances of the same invocation).

It is technically possible to have a folder be read by multiple invocation, but
it is not advisable as the behavior is undefined : which invocation will
process a file in the folder is anyone's guess. It also breaks the ``pmjq`` UNIX
security model.

The ``pmjq`` UNIX security model is as follow:

- Each directory is owned by a specific group
- Each invocation (and thus the processes it launches) is run by a specific\
user.
- This user owns all the input directories.
- This user belongs to the groups of the input and output directories of its\
invocation.

That way, if a process launched by an invocation of ``pmjq`` goes awry, it
will at most do damage only in its input and output folders, and nowhere else.

This security model is enforced by using the scripts generated by
``pmjq_interactive``.

FIXME: Implement this model somehow

Tools
======

``pmjq_interactive``
-----------------------------

The ``pmjq_interactive`` tool generates three shell scripts.
 - The first one (``setup.sh``) creates the directories, users and groups and\
sets the permissions.
 - The second one (``launch.sh``) launches the daemons.
 - The last one (``cleanup.sh``) removes the directories, users and groups.

The user is asked, in order:
 - which command ``pmjq`` is supposed to launch,
 - which are the input directories,
 - which are the output directories.

This tuple ``(input, cmd, output)`` is called an `invocation`, because it will,
in ``launch.sh``, map to one invocation of ``pmjq``.

A transcript of a user setting up the first two invocations of our example
pipeline using this tool would begin like this::


    Command:decode
    Input dir(s):input/
    Output dir(s):decoded/
    Command:stabilize
    Input dir(s):decoded/
    Output dir(s):stabilized/


The generated scripts may have to be tweaked afterwards to add
mounting/unmounting of remote, RAM or virtual file systems, or to add options
(e.g. ``--max-load``) to the invocations of ``pmjq``. They lend themselves
quite well to merging, diffing and version control.

The ``pmjq_interactive`` tool can also be used non interactively, by storing
in a file the answers one would give to the tool's questions. Comments can be
added by starting a line with a #, such as:

.. literalinclude:: ../paper/whole_pipeline.txt

Such a file may be used on the command line with::

    grep -v -E '^#' < whole_pipeline.txt | pmjq_interactive

``pmjq_viz`` 
--------------------

The ``pmjq_viz`` tool lets you visualize the pipeline.

It analyzes the ``setup.sh`` script generated by the ``pmjq_interactive`` tool
and outputs the resulting graph in dot language. To see it in e.g. pdf, one
can run::

    pmjq_viz < setup.sh | dot -T pdf > whole_pipeline.pdf

The fact that the vizualisation tool works from the ``setup.sh`` script instead
of using the user input given to ``pmjq_interactive`` is an important feature
as one can be sure that what we see is what is going to be executed.

'''
from .dsl import normalize, pmjq_command
import os
import daemux  # FIXME: add daemux to the requirements in setup.py
import shlex


def create_endpoints(transitions):
    """Create all directories that the given transitions need."""
    for t in transitions:
        t = normalize(t)
        for endpoint in sum([t[x] for x in ['inputs', 'outputs', 'errors']
                             if x in t], []) + [t['stderr']]:
            os.makedirs(os.path.dirname(endpoint), exist_ok=True)


COMMAND_TEMPLATES = {
    "log": "lnav {log}",
    "directories": "for dir in {dirs}; do echo $dir; ls -1 $dir | wc -l; done",
    "stderr": "tail {stderr}/$(ls -1t {stderr} | head -1); ls {stderr}",
    "htop": "htop",
}


def daemux_start(transitions, session="pmjq", shell='sh'):
    """Instantiate the transitions, one in its own tmux window."""
    for t in transitions:
        t = normalize(t)
        commands = []
        # Template "directories" deals with watch-able templates
        # that use a list as input
        for dirs_key in [x for x in ["inputs", "outputs", "errors"]
                         if x in t]:
            commands.append("watch -n1 "+shlex.quote(
                COMMAND_TEMPLATES['directories'].format(
                    dirs=' '.join(
                        map(lambda d: shlex.quote(os.path.dirname(d)),
                            t[dirs_key])))))
        # Template "stderr" deals with the log files
        if "stderr" in t:
            commands.append("watch -n1 "+shlex.quote(
                COMMAND_TEMPLATES['stderr'].format(
                    stderr=shlex.quote(os.path.dirname(t['stderr'])))))
        # The command
        if shell == "sh":
            commands.append(pmjq_command(t))
        elif shell == 'fish':
            commands.append(pmjq_command(t, redirect='^'))
        # The other templates can be used as is
        for k in [k for k in COMMAND_TEMPLATES
                  if k not in ['directories', 'stderr', 'cmd']]:
            commands.append(COMMAND_TEMPLATES[k].format(**t))
        for cmd in commands:
            daemux.start(cmd, session=session, window=t['id'], layout='tiled')


def get_str(*args):
    """Create dot edges and nodes in dot format.
    Args are, in order :
    node_name, shape, color, label,
    node2_name, shape2, color2, label2,
    arrowhead, arrowstyle, arrowcolor, arrowweight.

    Used to fill tran2dot data.
    """
    args = [args[i] if i < len(args) else "" for i in range(12)]
    return ("    {{"
            "\"{}\" [shape = \"{}\", color = \"{}\", label = \"{}\"]"
            "}} -> {{"
            "\"{}\" [shape = \"{}\", color = \"{}\", label = \"{}\"]"
            "}}"
            " [arrowhead = \"{}\", style = \"{}\", color = \"{}\","
            " weight = {}];\n"
            ).format(*args)


def tran2dot(transition, logs=False):
    """Transform a pmjq transition into a dot string.

    :param transition: The transition to convert
    :param logs: Include the 'logs' field
    :return: The dot string, and the error list (for further processing)
    """
    dot = ""
    tr = transition.get("id")
    errors = []
    for i in transition.get("inputs", []):
        name = os.path.dirname(i)
        label = "dir_" + name
        dot += get_str(label, "oval", "blue", name,
                       tr, "box", "green", tr,
                       "normal", "", "blue", "10")
    for o in transition.get("outputs", []):
        name = os.path.dirname(o)
        label = "dir_" + name
        dot += get_str(tr, "box", "green", tr,
                       label, "oval", "blue", name,
                       "normal", "", "blue", "10")
    for e in transition.get("errors", []):
        name = os.path.dirname(e)
        label = "dir_" + name
        dot += get_str(tr, "box", "green", tr,
                       label, "hexagon", "red", name,
                       "none", "dotted", "red", "1")
        errors.append("\"{}\"".format(label))
    for s in transition.get("side_effects", []):
        dot += get_str(tr, "box", "green", tr,
                       "se_"+s, "diamond", "purple", s,
                       "none", "", "purple", "2")
    l = transition.get("stderr", "")
    if l and logs:
        l = os.path.dirname(l)
        label = "dir_" + l
        dot += get_str(tr, "box", "green", tr,
                       label, "octagon", "darkorange", l,
                       "none", "", "darkorange", "2")
    return dot, errors


def process_transitions(transitions, group=True):
    """Convert a pmjq transition dict into a dot-readable string.

    :param transitions: The dict containing transitions
    :param group: Group errors in a cluster
    :return: The dot string
    """
    dot = "digraph transitions {\n"
    dot += "    rankdir = TB;\n"
    dot += "    splines=ortho;\n"
    dot += "    node[penwidth=2.0];\n"
    errors = []
    for t in transitions:
        d, err = tran2dot(normalize(t))
        dot += d
        errors += err
    if group and len(errors) > 0:  # Dirty hack to gather errors
        dot += "subgraph cluster_errors {{\n"\
               "color=none\nedge[style=invis]\n{}\n"\
               "}}\n".format(" -> ".join(errors))
    dot += "}"
    return dot
