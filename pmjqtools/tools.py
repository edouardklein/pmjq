'''
The ``pmjq`` UNIX security model
================================

``pmjq`` relies on standard UNIX tooling and permissions to make sure a rogue,
compromised, or buggy program can do only limited damage.

A folder should only be read by one invocation at a time (but can be read by
multiple instances of the same invocation).

It is technically possible to have a folder be read by multiple invocation, but
it is not advisable as the behavior is undefined : which invocation will
process a file in the folder is anyone's guess. It also breaks the ``pmjq`` UNIX
security model.

The ``pmjq`` UNIX security model is as follow:

- Each directory is owned by a specific group
- Each invocation (and thus the processes it launches) is run by a specific\
user.
- This user owns all the input directories.
- This user belongs to the groups of the input and output directories of its\
invocation.

That way, if a process launched by an invocation of ``pmjq`` goes awry, it
will at most do damage only in its input and output folders, and nowhere else.

This security model is enforced by using the scripts generated by
``pmjq_interactive``.

FIXME: Implement this model somehow

Tools
======

``pmjq_interactive``
-----------------------------

The ``pmjq_interactive`` tool generates three shell scripts.
 - The first one (``setup.sh``) creates the directories, users and groups and\
sets the permissions.
 - The second one (``launch.sh``) launches the daemons.
 - The last one (``cleanup.sh``) removes the directories, users and groups.

The user is asked, in order:
 - which command ``pmjq`` is supposed to launch,
 - which are the input directories,
 - which are the output directories.

This tuple ``(input, cmd, output)`` is called an `invocation`, because it will,
in ``launch.sh``, map to one invocation of ``pmjq``.

A transcript of a user setting up the first two invocations of our example
pipeline using this tool would begin like this::


    Command:decode
    Input dir(s):input/
    Output dir(s):decoded/
    Command:stabilize
    Input dir(s):decoded/
    Output dir(s):stabilized/


The generated scripts may have to be tweaked afterwards to add
mounting/unmounting of remote, RAM or virtual file systems, or to add options
(e.g. ``--max-load``) to the invocations of ``pmjq``. They lend themselves
quite well to merging, diffing and version control.

The ``pmjq_interactive`` tool can also be used non interactively, by storing
in a file the answers one would give to the tool's questions. Comments can be
added by starting a line with a #, such as:

.. literalinclude:: ../paper/whole_pipeline.txt

Such a file may be used on the command line with::

    grep -v -E '^#' < whole_pipeline.txt | pmjq_interactive

``pmjq_viz`` 
--------------------

The ``pmjq_viz`` tool lets you visualize the pipeline.

It analyzes the ``setup.sh`` script generated by the ``pmjq_interactive`` tool
and outputs the resulting graph in dot language. To see it in e.g. pdf, one
can run::

    pmjq_viz < setup.sh | dot -T pdf > whole_pipeline.pdf

The fact that the vizualisation tool works from the ``setup.sh`` script instead
of using the user input given to ``pmjq_interactive`` is an important feature
as one can be sure that what we see is what is going to be executed.

'''
from .dsl import normalize, pmjq_command
import os
import daemux  # FIXME: add daemux to the requirements in setup.py
import shlex
from collections import defaultdict
from string import Formatter


def create_endpoints(transitions):
    """Create all directories that the given transitions need."""
    for t in transitions:
        t = normalize(t)
        for endpoint in sum([t[x] for x in ['inputs', 'outputs', 'errors']
                             if x in t], []) + [t['stderr']]:
            os.makedirs(os.path.dirname(endpoint), exist_ok=True)


COMMAND_TEMPLATES = {
    "log": "lnav {log}",
    "directories": "for dir in {dirs}; do echo $dir; ls -1 $dir | wc -l; done",
    "stderr": "tail {stderr}/$(ls -1t {stderr} | head -1); ls {stderr}",
    "htop": "htop",
}


def daemux_start(transitions, session="pmjq", shell='sh'):
    """Instantiate the transitions, one in its own tmux window."""
    for t in transitions:
        t = normalize(t)
        commands = []
        # Template "directories" deals with watch-able templates
        # that use a list as input
        for dirs_key in [x for x in ["inputs", "outputs", "errors"]
                         if x in t]:
            commands.append("watch -n1 "+shlex.quote(
                COMMAND_TEMPLATES['directories'].format(
                    dirs=' '.join(
                        map(lambda d: shlex.quote(os.path.dirname(d)),
                            t[dirs_key])))))
        # Template "stderr" deals with the log files
        if "stderr" in t:
            commands.append("watch -n1 "+shlex.quote(
                COMMAND_TEMPLATES['stderr'].format(
                    stderr=shlex.quote(os.path.dirname(t['stderr'])))))
        # The command
        if shell == "sh":
            commands.append(pmjq_command(t))
        elif shell == 'fish':
            commands.append(pmjq_command(t, redirect='^'))
        # The other templates can be used as is
        for k in [k for k in COMMAND_TEMPLATES
                  if k not in ['directories', 'stderr', 'cmd']]:
            commands.append(COMMAND_TEMPLATES[k].format(**t))
        for cmd in commands:
            daemux.start(cmd, session=session, window=t['id'], layout='tiled')


def dot_nodes_and_edge(**kwargs):
    """Return the dot code for two nodes and an edge"""
    print("DBG", defaultdict(lambda: "", **kwargs))
    return Formatter().vformat('''{{ "{node1}" [shape="{shape1}", color="{color1}", label="{label1}"]}} ->
    {{"{node2}" [shape="{shape2}", color="{color2}", label="{label2}"]}}
    [arrowhead="{ahead}", style="{astyle}",color="{acolor}",weight={aweight}];
    ''', (), defaultdict(lambda: "", **kwargs))


def trans2dot(transition, logs=False):
    """Transform a pmjq transition into a dot string.

    :param transition: The transition to convert
    :param logs: Include the 'logs' field
    :return: The dot string, and the error list (for further processing)
    """
    dot = ""
    tr = transition.get("id")
    errors = []
    for i in transition.get("inputs", []):
        name = os.path.dirname(i)
        dot += dot_nodes_and_edge(node1='dir_'+name, shape1="oval",
                                  color1="blue", label1=name,
                                  node2=tr, shape2="box",
                                  color2="green", label2=tr,
                                  ahead="normal", acolor="blue", aweight="10")
    for o in transition.get("outputs", []):
        name = os.path.dirname(o)
        dot += dot_nodes_and_edge(node1=tr, shape1="box",
                                  color1="green", label1=tr,
                                  node2='dir_'+name, shape2="oval",
                                  color2="blue", label2=name,
                                  ahead="normal", acolor="blue", aweight="10")
    for e in transition.get("errors", []):
        name = os.path.dirname(e)
        dot += dot_nodes_and_edge(node1=tr, shape1="box",
                                  color1="green", label1=tr,
                                  node2='dir_'+name, shape2="hexagon",
                                  color2="red", label2=name,
                                  ahead="none", astyle="dotted", acolor="red",
                                  aweight="1")
        errors.append('"dir_{}"'.format(name))
    for s in transition.get("side_effects", []):
        dot += dot_nodes_and_edge(node1=tr, shape1="box",
                                  color1="green", label1=tr,
                                  node2='se_'+s, shape2="diamond",
                                  color2="purple", label2=s,
                                  ahead="none", acolor="purple", aweight="1")
    l = transition.get("stderr", "")
    if l and logs:
        l = os.path.dirname(l)
        dot += dot_nodes_and_edge(node1=tr, shape1="box",
                                  color1="green", label1=tr,
                                  node2='dir_'+l, shape2="octagon",
                                  color2="darkorange", label2=l,
                                  ahead="none", acolor="darkorange",
                                  aweight="2")
    return dot, errors


def process_transitions(transitions, group=True, logs=False):
    """Convert a pmjq transition dict into a dot-readable string.

    :param transitions: The dict containing transitions
    :param group: Group errors in a cluster
    :return: The dot string
    """
    dot = "digraph transitions {\n"
    dot += "    rankdir = TB;\n"
    dot += "    splines=ortho;\n"
    dot += "    node[penwidth=2.0];\n"
    errors = []
    for t in transitions:
        d, err = trans2dot(normalize(t), logs=logs)
        dot += d
        errors += err
    if group and len(errors) > 0:  # Dirty hack to gather errors
        dot += "subgraph cluster_errors {{\n"\
               "color=none\nedge[style=invis]\n{}\n"\
               "}}\n".format(" -> ".join(errors))
    dot += "}"
    return dot
