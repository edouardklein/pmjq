'''
The ``pmjq`` UNIX security model
================================

``pmjq`` relies on standard UNIX tooling and permissions to make sure a rogue,
compromised, or buggy program can do only limited damage.

A folder should only be read by one invocation at a time (but can be read by
multiple instances of the same invocation).

It is technically possible to have a folder be read by multiple invocation, but
it is not advisable as the behavior is undefined : which invocation will
process a file in the folder is anyone's guess. It also breaks the ``pmjq`` UNIX
security model.

The ``pmjq`` UNIX security model is as follow:

- Each directory is owned by a specific group
- Each invocation (and thus the processes it launches) is run by a specific\
user.
- This user owns all the input directories.
- This user belongs to the groups of the input and output directories of its\
invocation.

That way, if a process launched by an invocation of ``pmjq`` goes awry, it
will at most do damage only in its input and output folders, and nowhere else.

This security model is enforced by using the scripts generated by
``pmjq_interactive``.

FIXME: Implement this model somehow

Tools
======

``pmjq_interactive``
-----------------------------

The ``pmjq_interactive`` tool generates three shell scripts.
 - The first one (``setup.sh``) creates the directories, users and groups and\
sets the permissions.
 - The second one (``launch.sh``) launches the daemons.
 - The last one (``cleanup.sh``) removes the directories, users and groups.

The user is asked, in order:
 - which command ``pmjq`` is supposed to launch,
 - which are the input directories,
 - which are the output directories.

This tuple ``(input, cmd, output)`` is called an `invocation`, because it will,
in ``launch.sh``, map to one invocation of ``pmjq``.

A transcript of a user setting up the first two invocations of our example
pipeline using this tool would begin like this::


    Command:decode
    Input dir(s):input/
    Output dir(s):decoded/
    Command:stabilize
    Input dir(s):decoded/
    Output dir(s):stabilized/


The generated scripts may have to be tweaked afterwards to add
mounting/unmounting of remote, RAM or virtual file systems, or to add options
(e.g. ``--max-load``) to the invocations of ``pmjq``. They lend themselves
quite well to merging, diffing and version control.

The ``pmjq_interactive`` tool can also be used non interactively, by storing
in a file the answers one would give to the tool's questions. Comments can be
added by starting a line with a #, such as:

.. literalinclude:: ../paper/whole_pipeline.txt

Such a file may be used on the command line with::

    grep -v -E '^#' < whole_pipeline.txt | pmjq_interactive

``pmjq_viz`` 
--------------------

The ``pmjq_viz`` tool lets you visualize the pipeline.

It analyzes the ``setup.sh`` script generated by the ``pmjq_interactive`` tool
and outputs the resulting graph in dot language. To see it in e.g. pdf, one
can run::

    pmjq_viz < setup.sh | dot -T pdf > whole_pipeline.pdf

The fact that the vizualisation tool works from the ``setup.sh`` script instead
of using the user input given to ``pmjq_interactive`` is an important feature
as one can be sure that what we see is what is going to be executed.

'''
from .dsl import normalize
import os


def create_endpoints(transitions):
    for t in transitions:
        t = normalize(t)
        for endpoint in sum([t[x] for x in ['inputs', 'outputs', 'errors']
                             if x in t], []):
            os.makedirs(endpoint, exist_ok=True)
